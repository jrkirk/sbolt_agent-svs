#### propose explanation operator, when popping of the segment from the stack when the reason for popping is "completed action <new action>". because the agent is relying on instructor to determine when the action has successfully ended, it means that the operator application is unkown to the agent and should be learned

### for coding purposes proposing explain operator at topstate; fix it such that it fires only at appropriate places

sp {topstate*propose*explain*operator
   (state <s> ^topstate <s>
   	      ^interaction.stack.segment <top>
	      -^operator.name push-segment
        	#-^status.performed.learning-event explanation) #AM: Changed performed structure
	      -^status.performed.learning-event.type explanation)
   (<top> ^purpose <p>
   	  ^next <next>)
   (<p> ^type explanation)
-->
   (<s> ^operator <op> + >)
   (<op> ^name explain
   	 ^segment <next>)
}

sp {elaborate*explain*dont-learn
   (state <s> ^name explain)
-->
   (dont-learn <s>)
}

sp {elaborate*explain*query
   (state <s> ^name explain
   	      ^superstate.operator <op>)
   (<op> ^name explain
   	 ^segment <top>)
-->
   (<s> ^segment <top>)

} 

## in the explain operator, query episodic memory for the time when segment top was first seen on the top of the stack

sp {explain*retrieve*episode*episodic*memory*2
   (state <s> ^name explain
   	      ^segment <seg>
	      ^epmem.command <epcom>)
   (<seg> ^epmem-id <id>)
-->
   (<epcom> ^retrieve <id>)
} 

### if the retrieval is successful; copy all the relevant attributes from the retrieved episode to this state

sp {explain*copy*retrieved*episode*object
   (state <s> ^name explain
   	      ^epmem.result <res>)
   (<res> ^retrieved <ret>
   	  ^memory-id <mem-id>)
   (<ret> ^object <obj>)
   -->
   (<s> ^object <obj>)
}

sp {explain*copy*retrieved*episode*self
   (state <s> ^name explain
   	      ^epmem.result <res>)
   (<res> ^retrieved <ret>
   	  ^memory-id <mem-id>)
   (<ret> ^self <obj>)
   -->
   (<s> ^self <obj>)
}



## in the explanation state, generate the desired state
#sp {explain*propose*assign-goal
#   (state <s> ^name explain
#   	      ^segment.purpose.indexed-operator <iop>
#	      -^desired <any>)
#   (<iop> ^goal-lid <glid>)
#-->
#   (<s> ^operator <op> + >)
#   (<op> ^name assign-goal
#   	 ^long-term-id <glid>)
#}

### in the generated state, propose the verb on the segment
sp {explain*propose*segment-verb
   (state <s> ^name explain
   	      ^segment <seg>)
   (<seg> ^purpose <p>)
   (<p> ^indexed-operator <map-op>) 
   (<map-op> ^name <name>)
-->
   (<s> ^operator <new-op> + >)
   (<new-op> ^name <name>)
}

sp {explain*propose*segment-verb*elaborate
   (state <s> ^name explain
   	      ^segment.purpose.indexed-operator <map-op>	
	      ^operator <op> +
	      ^object <obj>)
   (<op> ^name <name>)
   (<map-op> ^name <name>
   	     ^<arg> <val>)
   (<val> ^id <id>)
   (<obj> ^id <id>)
   -->
   (<op> ^<arg> <obj>)
   (<obj> ^focus yes)
}

##### more generalized version of desired
sp {new-operator*desired*generalized
   (state <s> ^name <sname>
   	      ^superstate <ss>
	      ^object <val1>
	      ^object <val2>)
   (<ss> ^operator <sop>)
   (<sop> ^name <sname>
   	  ^{<arg1> <> name <> goal-lid <> applied <> category <> indexed-operator <> information <> success} <val1>
	  ^{<arg2> <> name  <> goal-lid <> applied <> category <> indexed-operator <> information <> success} <val2>)
   (<val2> ^category location)
   (<val1> -^category location)
-->
   (<s> ^desired <d>)
   (<d> ^track-relation <in-p>)
   (<in-p> ^object1 <val1>
   	   ^object2 <val2>
	   ^prep in)
}

### --- reject operator if desired state is reached

sp {new-operator*reject
   (state <s> ^name <sname>
   	      ^superstate <ss> 
	      ^learning-operator <sname>
	      ^desired <d>
	      ^success <d>)
   (<sop> ^name <sname>)
   (<ss> ^name explain
   	 ^operator <sop>)
-->
   (<ss> ^operator <sop>
   	 ^successful-explanation <sname>)
}


### once successful explanation has been reached; pop the pupose; see resolve-stack in conversation-manager

sp {explain*success
   (state <s> ^name explain
   	      ^successful-explanation <op-name>
	      ^topstate.status <status>)
-->
   #(<stat> ^performed <p>)
   #(<p> ^learning-event explanation)
   # AM: Changed performed structure
   (<status> ^performed.learning-event <e>)
   (<e> ^type explanation)
}
	      


### temporary composite operator reject
#sp {composite*operator*elaborate*success
#   (state <s> ^name <sname>
#   	      ^superstate <ss>)
#   (<ss> ^operator <sop>
#   	 ^indexed-operator <iop>)
#   (<sop> ^category composite-action)
#   (<sop> ^name <sname>)
#   (<s> ^desired <d>
#   	^success <d>)
#-->
#   (<ss> ^composite-success <sop>)
#   (<iop> ^applied true)
#}

### o-support
sp {propose*composite*operator*elaborate*success
   (state <s> ^name <sname>
   	      ^superstate <ss>
	      -^learning-operator <any>)
   (<ss> ^operator <sop>
   	 ^indexed-operator <iop>)
   (<sop> ^category composite-action)
   (<sop> ^name <sname>)
   (<s> ^desired <d>
   	^success <d>)
-->
   (<s> ^operator <op> + > !)
   (<op> ^name mark-success
	 ^indexed-operator <iop>)
}
sp {apply*composite*operator*elaborate*success
   (state <s> ^operator <op>
   	      ^superstate <ss>
	      ^topstate.status <status>)
   (<op> ^name mark-success
	 ^indexed-operator <iop>)
   (<iop> ^information <info>)
 -->
   (<ss> ^indexed-operator <iop> -)
   #(<status> ^performed.action-event <info>)
   # AM: Changed performed structure
   (<status> ^performed.action-event <e>)
   (<e> ^type <info>)
}

## prefer mark success to primitive actions
sp {prefer*mark*success
   (state <s> ^operator <op1> +
   	      ^operator <op2> +)
   (<op1> ^name mark-success)
   (<op2> ^category primitive-action)
-->
   (<s> ^operator <op1> > <op2>)
}
   	 
sp {composite*operator*retract
   (state <s> ^composite-success <op>
   	      ^operator <op>
	      ^indexed-operator <op>)
-->
   (<s> ^operator <op> -)
}


### get focus to work
sp {composite*operator*elaborate*focus
   (state <s> ^name <sname>
   	      ^superstate <ss>
	      ^object <val1>
	      ^object <val2>)
   (<ss> ^operator <sop>)
   (<sop> ^category composite-action
   	  ^name <sname>
   	  ^{<arg1> <> name} <val1>
	  ^{<arg2> <> name} <val2>)
   (<val2> ^category location)
   (<val1> -^category location)
 -->
   (<val2> ^focus yes)
   (<val1> ^focus yes)
}

### clean up focus
sp {object*clean-up*focus
   (state <s> ^topstate <s>
   	      ^object <obj>
	      ^operator <op>)
   (<op> ^category << interaction-stack communication >>)
   (<obj> ^focus yes)
-->
   (<obj> ^focus yes -)
}